<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merge Master</title>
	<link id="styles-link" rel="stylesheet" type="text/css">
	<!--<link rel="stylesheet" type="text/css" href="styles_iOS.css">-->
	<!--<link rel="stylesheet" type="text/css" href="styles_PC_Android.css">-->
	<script src="https://telegram.org/js/telegram-web-app.js"></script> <!--Подключаем скрипт от телеграм-->
	<script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>

</head>
<body>
	
    <div id="score">Score: 0</div>
    <div id="game-container"></div>
    <div id="game-overlay">
        <button id="new-game-button">&#8634;</button>
    </div>
	    
	<div id="ton-connect"></div>
	
    <script>
        // Function to determine user device type
        function getUserDeviceType() {
            // Assuming iOS devices use 'iPhone', 'iPad', or 'iPod' in user agent string
            return /(iPhone|iPod|iPad)/i.test(navigator.userAgent) ? 'iOS' : 'PC_Android';
        }

        // Function to apply device-specific class to <html> tag
        function applyDeviceClass() {
            const deviceType = getUserDeviceType();
            document.documentElement.classList.add(deviceType);
        }

        // Call function to apply device-specific class after the document is fully loaded
        window.addEventListener('load', function() {
            applyDeviceClass();
        });

        // Function to apply styles based on user device type
        function applyStylesForDevice() {
            const htmlTag = document.documentElement;
            const stylesLink = document.getElementById('styles-link');
            if (htmlTag.classList.contains('iOS')) {
                stylesLink.href = 'styles_iOS.css';
            } else {
                stylesLink.href = 'styles_PC_Android.css';
            }
        }

        // Call function to apply styles based on user device type after the document is fully loaded
        window.addEventListener('load', function() {
			const deviceType = getUserDeviceType();
            console.log('User device type:', deviceType);
            applyStylesForDevice();
        });
    </script>

  	<script>
		window.addEventListener('beforeunload', (event) => {
		event.preventDefault();
		event.returnValue = '';
		});
	</script>
	<script>
    const tonConnectUI = new TON_CONNECT_UI.TonConnectUI({
        manifestUrl: 'https://kaydgacadem.github.io/MergeMaster//tonconnect-manifest.json',
        buttonRootId: 'ton-connect'
    });
	
    async function connectToWallet() {
        const connectedWallet = await tonConnectUI.connectWallet();
        // Do something with connectedWallet if needed
        console.log(connectedWallet);
    }

    // Call the function
    connectToWallet().catch(error => {
        console.error("Error connecting to wallet:", error);
    });
	</script>
	
	
	
    <script>
		let tg = window.Telegram.WebApp; //получаем объект webapp телеграма
		tg.expand();

        // Определение размера игрового поля
        const BOARD_SIZE = 4;
        let score = 0; // Переменная для хранения счета

        // Создание новой игры
        function newGame() {
            let board = new Array(BOARD_SIZE).fill(0).map(() => new Array(BOARD_SIZE).fill(0));
            addNewTile(board);
            addNewTile(board);
            return board;
        }

        // Добавление новой плитки на игровое поле
        function addNewTile(board) {
            let emptyCells = [];
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === 0) {
                        emptyCells.push({ x: i, y: j });
                    }
                }
            }
            if (emptyCells.length > 0) {
                let { x, y } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                board[x][y] = Math.random() < 0.9 ? 2 : 4;
            }
        }

        // Увеличение счета
        function increaseScore(value) {
            score += value;
            document.getElementById('score').textContent = 'Score: ' + score;
        }

        // Проверка наличия доступных ходов
        function checkMovesAvailable(board) {
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === 0) {
                        return true; // Есть пустая ячейка
                    }
                    if ((i < BOARD_SIZE - 1 && board[i][j] === board[i + 1][j]) || // Есть возможные слияния по вертикали
                        (j < BOARD_SIZE - 1 && board[i][j] === board[i][j + 1])) { // Есть возможные слияния по горизонтали
                        return true;
                    }
                }
            }
            return false; // Ходы больше не возможны
        }

        // Выполнение хода
        function move(board, direction) {
            let newBoard = JSON.parse(JSON.stringify(board)); // Создание копии игрового поля
            switch (direction) {
                case 'up':
                    return moveUp(newBoard);
                case 'down':
                    return moveDown(newBoard);
                case 'left':
                    return moveLeft(newBoard);
                case 'right':
                    return moveRight(newBoard);
                default:
                    return board;
            }
        }

        // Перемещение чисел вверх и слияние одинаковых чисел
        function moveUp(board) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                for (let i = 1; i < BOARD_SIZE; i++) {
                    if (board[i][j] !== 0) {
                        let k = i;
                        while (k > 0 && (board[k - 1][j] === 0 || board[k - 1][j] === board[k][j])) {
                            if (board[k - 1][j] === board[k][j]) {
                                board[k - 1][j] *= 2;
                                increaseScore(board[k - 1][j]); // Увеличение счета при слиянии
                                board[k][j] = 0;
                                break;
                            }
                            if (board[k - 1][j] === 0) {
                                board[k - 1][j] = board[k][j];
                                board[k][j] = 0;
                            }
                            k--;
                        }
                    }
                }
            }
            return board;
        }

        // Перемещение чисел вниз и слияние одинаковых чисел
        function moveDown(board) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                for (let i = BOARD_SIZE - 2; i >= 0; i--) {
                    if (board[i][j] !== 0) {
                        let k = i;
                        while (k < BOARD_SIZE - 1 && (board[k + 1][j] === 0 || board[k + 1][j] === board[k][j])) {
                            if (board[k + 1][j] === board[k][j]) {
                                board[k + 1][j] *= 2;
                                increaseScore(board[k + 1][j]); // Увеличение счета при слиянии
                                board[k][j] = 0;
                                break;
                            }
                            if (board[k + 1][j] === 0) {
                                board[k + 1][j] = board[k][j];
                                board[k][j] = 0;
                            }
                            k++;
                        }
                    }
                }
            }
            return board;
        }

        // Перемещение чисел влево и слияние одинаковых чисел
        function moveLeft(board) {
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 1; j < BOARD_SIZE; j++) {
                    if (board[i][j] !== 0) {
                        let k = j;
                        while (k > 0 && (board[i][k - 1] === 0 || board[i][k - 1] === board[i][k])) {
                            if (board[i][k - 1] === board[i][k]) {
                                board[i][k - 1] *= 2;
                                increaseScore(board[i][k - 1]); // Увеличение счета при слиянии
                                board[i][k] = 0;
                                break;
                            }
                            if (board[i][k - 1] === 0) {
                                board[i][k - 1] = board[i][k];
                                board[i][k] = 0;
                            }
                            k--;
                        }
                    }
                }
            }
            return board;
        }

        // Перемещение чисел вправо и слияние одинаковых чисел
        function moveRight(board) {
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = BOARD_SIZE - 2; j >= 0; j--) {
                    if (board[i][j] !== 0) {
                        let k = j;
                        while (k < BOARD_SIZE - 1 && (board[i][k + 1] === 0 || board[i][k + 1] === board[i][k])) {
                            if (board[i][k + 1] === board[i][k]) {
                                board[i][k + 1] *= 2;
                                increaseScore(board[i][k + 1]); // Увеличение счета при слиянии
                                board[i][k] = 0;
                                break;
                            }
                            if (board[i][k + 1] === 0) {
                                board[i][k + 1] = board[i][k];
                                board[i][k] = 0;
                            }
                            k++;
                        }
                    }
                }
            }
            return board;
        }

        // Функция для отрисовки игрового поля
        function render(board) {
            let gameContainer = document.getElementById('game-container');
            gameContainer.innerHTML = ''; // Очищаем содержимое элемента

            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.textContent = board[i][j] === 0 ? '' : board[i][j];
                    cell.style.backgroundColor = getTileColor(board[i][j]);
                    gameContainer.appendChild(cell);
                }
            }

            // Проверка доступности ходов и отображение кнопки новой игры при необходимости
            if (!checkMovesAvailable(board)) {
                document.getElementById('game-overlay').classList.add('active'); // Добавляем класс для показа затемнения
            } else {
                document.getElementById('game-overlay').classList.remove('active'); // Удаляем класс, если ходы доступны
            }
        }

        // Функция для определения цвета плитки в зависимости от значения
        // Обновленная функция getTileColor
function getTileColor(value) {
    switch (value) {
        case 2:
            return 'tile-2';
        case 4:
            return 'tile-4';
        case 8:
            return 'tile-8';
        case 16:
            return 'tile-16';
        case 32:
            return 'tile-32';
        case 64:
            return 'tile-64';
        case 128:
            return 'tile-128';
        case 256:
            return 'tile-256';
        case 512:
            return 'tile-512';
        case 1024:
            return 'tile-1024';
        case 2048:
            return 'tile-2048';
        default:
            return 'tile-default';
    }
}


        // Обработка нажатия клавиш на клавиатуре
        document.addEventListener('keydown', function (event) {
            let direction;
            switch (event.key) {
                case 'ArrowUp':
                    direction = 'up';
                    break;
                case 'ArrowDown':
                    direction = 'down';
                    break;
                case 'ArrowLeft':
                    direction = 'left';
                    break;
                case 'ArrowRight':
                    direction = 'right';
                    break;
                default:
                    return;
            }
            // Выполнение хода и обновление игрового поля
            board = move(board, direction);
            addNewTile(board);
            render(board);
        });

        // Обработка касаний на сенсорном экране
        let startX, startY;

        document.getElementById('game-container').addEventListener('touchstart', function (event) {
            startX = event.touches[0].clientX;
            startY = event.touches[0].clientY;
        });

        document.getElementById('game-container').addEventListener('touchmove', function (event) {
            event.preventDefault();
        });

        document.getElementById('game-container').addEventListener('touchend', function (event) {
            let endX = event.changedTouches[0].clientX;
            let endY = event.changedTouches[0].clientY;

            let deltaX = endX - startX;
            let deltaY = endY - startY;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0) {
                    // Swipe right
                    board = move(board, 'right');
                } else {
                    // Swipe left
                    board = move(board, 'left');
                }
            } else {
                if (deltaY > 0) {
                    // Swipe down
                    board = move(board, 'down');
                } else {
                    // Swipe up
                    board = move(board, 'up');
                }
            }

            addNewTile(board);
            render(board);
        });

        // Инициализация игры
        let board = newGame();
        render(board);

        // Обработка клика на кнопке новой игры
        document.getElementById('new-game-button').addEventListener('click', function () {
            score = 0;
            document.getElementById('score').textContent = 'Score: ' + score;
            board = newGame();
            render(board);
        });
    </script>
</body>
</html>
