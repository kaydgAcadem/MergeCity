<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merge Master</title>
	<!--<link id="styles-link" rel="stylesheet" type="text/css">-->
	<!--<link rel="stylesheet" type="text/css" href="styles_iOS.css">-->
	<link rel="stylesheet" type="text/css" href="styles.css">
	<script src="https://telegram.org/js/telegram-web-app.js"></script> <!--Подключаем скрипт от телеграм-->
	<script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>
	
	<script>
		document.addEventListener("DOMContentLoaded", function() {
			let usercard = document.getElementById("usercard"); //получаем блок usercard
			let profName = document.createElement('p'); //создаем параграф

			// Проверяем, что данные пользователя загружены
			if (tg.initDataUnsafe && tg.initDataUnsafe.user) {
            profName.innerText = `${tg.initDataUnsafe.user.first_name} (${tg.initDataUnsafe.user.language_code})`;
			} else {
				profName.innerText = 'No Name';
			}
        
			//выдем username и код языка
			usercard.appendChild(profName); //добавляем 
		});
	</script>

	
	<script>
document.addEventListener("DOMContentLoaded", function() {
    // Получаем тип устройства пользователя
    var userAgent = navigator.userAgent || navigator.vendor || window.opera;
    var deviceType;

    if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
        deviceType = "iOS";
    } else {
        deviceType = "other";
    }

    // Функция для применения стиля text-shadow к элементам
    function applyTextShadow() {
        if (deviceType === "iOS") {
            var cells = document.querySelectorAll(".cell");
            var usercard = document.getElementById("usercard");

            cells.forEach(function(cell) {
                cell.style.textShadow = "0 0 10px rgba(255, 255, 255, 0.5)";
                cell.style.boxShadow = "0 0 30px rgba(255, 255, 255, 0.6)";
            });
            usercard.style.textShadow = "0 0 4px #fff, 0 0 9px #fff, 0 0 14px #0fa, 0 0 19px #0fa, 0 0 24px #00ffd0";
        }
    }

    // Вызываем функцию для применения стиля text-shadow при загрузке страницы
    applyTextShadow();    

    // Обработчик события при добавлении новой плитки на игровое поле
    document.addEventListener('DOMNodeInserted', function(event) {
        // Проверяем, что добавленный элемент - плитка
        if (event.target.classList && event.target.classList.contains('cell')) {
            // Вызываем функцию для применения стиля text-shadow к @keyframes flicker
            applyTextShadow();
        }
    });
});

	</script>

</head>
<body>
	
	<div class="container">
	<div id="usercard"></div>    
	<div id="ton-connect"></div>
	</div>
    <div id="score">Score: 0</div>
    <div id="game-container"></div>
    <div id="game-overlay">
        <button id="new-game-button">&#8634;</button>
    </div>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        const tonConnectUI = new TON_CONNECT_UI.TonConnectUI({
            manifestUrl: 'https://kaydgacadem.github.io/MergeMaster//tonconnect-manifest.json',
            buttonRootId: 'ton-connect'
        });

        // Функция для подключения к кошельку
        async function connectToWallet() {
            const connectedWallet = await tonConnectUI.connectWallet();
            // Do something with connectedWallet if needed
            console.log(connectedWallet);
        }

        // Обработчик события нажатия на кнопку подключения кошелька
        const connectButton = document.getElementById('ton-connect');
        connectButton.addEventListener('click', function () {
            connectToWallet().catch(error => {
                console.error("Error connecting to wallet:", error);
            });
        });
    });
</script>

	
    <script>
		let tg = window.Telegram.WebApp; //получаем объект webapp телеграма
		tg.expand();
		
        // Определение размера игрового поля
        const BOARD_SIZE = 4;
        let score = 0; // Переменная для хранения счета

        // Создание новой игры
        function newGame() {
            let board = new Array(BOARD_SIZE).fill(0).map(() => new Array(BOARD_SIZE).fill(0));
            addNewTile(board);
            addNewTile(board);
            return board;
        }

        // Добавление новой плитки на игровое поле
        function addNewTile(board) {
            let emptyCells = [];
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === 0) {
                        emptyCells.push({ x: i, y: j });
                    }
                }
            }
            if (emptyCells.length > 0) {
                let { x, y } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                board[x][y] = Math.random() < 0.9 ? 2 : 4;
            }
        }

        // Увеличение счета
        function increaseScore(value) {
            score += value;
            document.getElementById('score').textContent = 'Score: ' + score;
        }

        // Проверка наличия доступных ходов
        function checkMovesAvailable(board) {
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === 0) {
                        return true; // Есть пустая ячейка
                    }
                    if ((i < BOARD_SIZE - 1 && board[i][j] === board[i + 1][j]) || // Есть возможные слияния по вертикали
                        (j < BOARD_SIZE - 1 && board[i][j] === board[i][j + 1])) { // Есть возможные слияния по горизонтали
                        return true;
                    }
                }
            }
            return false; // Ходы больше не возможны
        }

        // Выполнение хода
        function move(board, direction) {
            let newBoard = JSON.parse(JSON.stringify(board)); // Создание копии игрового поля
            switch (direction) {
                case 'up':
                    return moveUp(newBoard);
                case 'down':
                    return moveDown(newBoard);
                case 'left':
                    return moveLeft(newBoard);
                case 'right':
                    return moveRight(newBoard);
                default:
                    return board;
            }
        }

        // Перемещение чисел вверх и слияние одинаковых чисел
        function moveUp(board) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                for (let i = 1; i < BOARD_SIZE; i++) {
                    if (board[i][j] !== 0) {
                        let k = i;
                        while (k > 0 && (board[k - 1][j] === 0 || board[k - 1][j] === board[k][j])) {
                            if (board[k - 1][j] === board[k][j]) {
                                board[k - 1][j] *= 2;
                                increaseScore(board[k - 1][j]); // Увеличение счета при слиянии
                                board[k][j] = 0;
                                break;
                            }
                            if (board[k - 1][j] === 0) {
                                board[k - 1][j] = board[k][j];
                                board[k][j] = 0;
                            }
                            k--;
                        }
                    }
                }
            }
            return board;
        }

        // Перемещение чисел вниз и слияние одинаковых чисел
        function moveDown(board) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                for (let i = BOARD_SIZE - 2; i >= 0; i--) {
                    if (board[i][j] !== 0) {
                        let k = i;
                        while (k < BOARD_SIZE - 1 && (board[k + 1][j] === 0 || board[k + 1][j] === board[k][j])) {
                            if (board[k + 1][j] === board[k][j]) {
                                board[k + 1][j] *= 2;
                                increaseScore(board[k + 1][j]); // Увеличение счета при слиянии
                                board[k][j] = 0;
                                break;
                            }
                            if (board[k + 1][j] === 0) {
                                board[k + 1][j] = board[k][j];
                                board[k][j] = 0;
                            }
                            k++;
                        }
                    }
                }
            }
            return board;
        }

        // Перемещение чисел влево и слияние одинаковых чисел
        function moveLeft(board) {
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 1; j < BOARD_SIZE; j++) {
                    if (board[i][j] !== 0) {
                        let k = j;
                        while (k > 0 && (board[i][k - 1] === 0 || board[i][k - 1] === board[i][k])) {
                            if (board[i][k - 1] === board[i][k]) {
                                board[i][k - 1] *= 2;
                                increaseScore(board[i][k - 1]); // Увеличение счета при слиянии
                                board[i][k] = 0;
                                break;
                            }
                            if (board[i][k - 1] === 0) {
                                board[i][k - 1] = board[i][k];
                                board[i][k] = 0;
                            }
                            k--;
                        }
                    }
                }
            }
            return board;
        }

        // Перемещение чисел вправо и слияние одинаковых чисел
        function moveRight(board) {
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = BOARD_SIZE - 2; j >= 0; j--) {
                    if (board[i][j] !== 0) {
                        let k = j;
                        while (k < BOARD_SIZE - 1 && (board[i][k + 1] === 0 || board[i][k + 1] === board[i][k])) {
                            if (board[i][k + 1] === board[i][k]) {
                                board[i][k + 1] *= 2;
                                increaseScore(board[i][k + 1]); // Увеличение счета при слиянии
                                board[i][k] = 0;
                                break;
                            }
                            if (board[i][k + 1] === 0) {
                                board[i][k + 1] = board[i][k];
                                board[i][k] = 0;
                            }
                            k++;
                        }
                    }
                }
            }
            return board;
        }

        // Функция для отрисовки игрового поля
        function render(board) {
            let gameContainer = document.getElementById('game-container');
            gameContainer.innerHTML = ''; // Очищаем содержимое элемента

            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.textContent = board[i][j] === 0 ? '' : board[i][j];
                    cell.style.backgroundColor = getTileColor(board[i][j]);
                    gameContainer.appendChild(cell);
                }
            }

            // Проверка доступности ходов и отображение кнопки новой игры при необходимости
            if (!checkMovesAvailable(board)) {
                document.getElementById('game-overlay').classList.add('active'); // Добавляем класс для показа затемнения
            } else {
                document.getElementById('game-overlay').classList.remove('active'); // Удаляем класс, если ходы доступны
            }
        }

        // Функция для определения цвета плитки в зависимости от значения
        // Обновленная функция getTileColor
// Функция для определения цвета плитки в зависимости от значения
function getTileColor(value) {
    switch (value) {
        case 2:
            return '#A3AAFF';
        case 4:
            return '#B696F4';
        case 8:
            return '#CA81E8';
        case 16:
            return '#DD6DDD';
        case 32:
            return '#E67D9A';
        case 64:
            return '#EA8579';
        case 128:
            return '#D26A7D';
        case 256:
            return '#BA4E80';
        case 512:
            return '#A23384';
        case 1024:
            return '#862E9C';
        case 2048:
            return '#6B2AB5';
        default:
            return 'tile-default';
    }
}

        // Обработка нажатия клавиш на клавиатуре
        document.addEventListener('keydown', function (event) {
            let direction;
            switch (event.key) {
                case 'ArrowUp':
                    direction = 'up';
                    break;
                case 'ArrowDown':
                    direction = 'down';
                    break;
                case 'ArrowLeft':
                    direction = 'left';
                    break;
                case 'ArrowRight':
                    direction = 'right';
                    break;
                default:
                    return;
            }
            // Выполнение хода и обновление игрового поля
            board = move(board, direction);
            addNewTile(board);
            render(board);
        });

        // Обработка касаний на сенсорном экране
        let startX, startY;

        document.getElementById('game-container').addEventListener('touchstart', function (event) {
            startX = event.touches[0].clientX;
            startY = event.touches[0].clientY;
        });

        document.getElementById('game-container').addEventListener('touchmove', function (event) {
            event.preventDefault();
        });

        document.getElementById('game-container').addEventListener('touchend', function (event) {
            let endX = event.changedTouches[0].clientX;
            let endY = event.changedTouches[0].clientY;

            let deltaX = endX - startX;
            let deltaY = endY - startY;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0) {
                    // Swipe right
                    board = move(board, 'right');
                } else {
                    // Swipe left
                    board = move(board, 'left');
                }
            } else {
                if (deltaY > 0) {
                    // Swipe down
                    board = move(board, 'down');
                } else {
                    // Swipe up
                    board = move(board, 'up');
                }
            }

            addNewTile(board);
            render(board);
        });

        // Инициализация игры
        let board = newGame();
        render(board);

        // Обработка клика на кнопке новой игры
        document.getElementById('new-game-button').addEventListener('click', function () {
            score = 0;
            document.getElementById('score').textContent = 'Score: ' + score;
            board = newGame();
            render(board);
        });
    </script>
</body>
</html>
