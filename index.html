<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marge Master</title>
	<script src="https://telegram.org/js/telegram-web-app.js"></script> <!--Подключаем скрипт от телеграм-->
	<script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>
    <style>
@font-face {
    font-family: 'Spacetron';
    src: url('fonts/spacetron-3.ttf') format('truetype');
}

body {
    font-family: 'Spacetron', Arial, sans-serif;
    background: linear-gradient(black, 70%, grey); /* Цвет фона в стиле synthwave */
    margin: 0;
    padding: 0;
    overflow: hidden; /* Запрет прокрутки */
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-image: url('images/background1920x1080.jpg');
    background-size: cover; /* Убедимся, что фон занимает всю область */
    background-position: center; /* Центрируем фон */
    flex-direction: column; /* Добавлено для вертикального выравнивания элементов */
}

#score 	{
	font-family: 'Spacetron', Arial, sans-serif;
    font-size: 36px;
    font-weight: bold;
    margin-bottom: 20px;
	animation: flicker 2s infinite alternate;
	color: #fff;
}
/* Flickering animation */
	@keyframes flicker {
	0%, 18%, 22%, 25%, 53%, 57%, 100% {

      text-shadow:
      0 0 4px #fff,
      0 0 11px #fff,
      0 0 19px #fff,
      0 0 40px #0fa,
      0 0 80px #0fa,
      0 0 90px #0fa,
      0 0 100px #00ffd0,
      0 0 150px #00ffd0;
  
	}
  	20%, 24%, 55% {        
		text-shadow: none;
	}    
}

#game-container {
    background-color: rgba(248, 249, 250, 0.5); /* Полупрозрачный фон */
    border-radius: 8px;
    box-shadow: 0 0 25px rgba(0, 255, 170, 0.5); /* Тень для контейнера */
    padding: 20px;
    display: grid;
    grid-template-columns: repeat(4, 70px);
    grid-template-rows: repeat(4, 70px);
    gap: 10px;
    position: relative; /* Добавлено для позиционирования кнопки */
}

.cell {
    border-radius: 8px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 26px;
    font-weight: bold;
    color: #fdfdfd;
    text-shadow: 0 0 10px #fff;/* 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975; /* Добавим текстовую тень */
    background-color: #000; /* Цвет фона для клеток */
    box-shadow: 0 0 30px #fff; /* Тень для клеток */
}

#game-overlay {
    display: none;
}

#game-overlay.active {
    display: flex; /* Показываем затемнение */
}

#new-game-button {
    background-color: rgba(173, 173, 173, 0.8); /* Цвет кнопки */
    color: #fff; /* Цвет текста кнопки */
    border: none;
    border-radius: 8px;
    width: 375px;
    height: 375px;
    font-size: 70px;
	font-weight: bold;
    cursor: pointer;
    position: absolute;
    top: 49%;
    left: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 25px #0fa; /* Тень для кнопки */
    text-shadow: 0 0 25px #0fa; /* Тень для текста кнопки */
}

#ton-connect 	{
	margin-top: 40px;
}

</style>
</head>
<body>
	
    <div id="score">Score: 0</div>
    <div id="game-container"></div>
    <div id="game-overlay">
        <button id="new-game-button">&#8634;</button>
    </div>
	
    
	<div id="ton-connect"></div>
	<script>
		window.addEventListener('beforeunload', (event) => {
		event.preventDefault();
		event.returnValue = '';
		});
	</script>
	<script>
    const tonConnectUI = new TON_CONNECT_UI.TonConnectUI({
        manifestUrl: 'https://kaydgacadem.github.io/MergeMaster//tonconnect-manifest.json',
        buttonRootId: 'ton-connect'
    });
	
    async function connectToWallet() {
        const connectedWallet = await tonConnectUI.connectWallet();
        // Do something with connectedWallet if needed
        console.log(connectedWallet);
    }

    // Call the function
    connectToWallet().catch(error => {
        console.error("Error connecting to wallet:", error);
    });
	</script>
	
	
	
    <script>
		let tg = window.Telegram.WebApp; //получаем объект webapp телеграма
		tg.expand();
        // Определение размера игрового поля
        const BOARD_SIZE = 4;
        let score = 0; // Переменная для хранения счета

        // Создание новой игры
        function newGame() {
            let board = new Array(BOARD_SIZE).fill(0).map(() => new Array(BOARD_SIZE).fill(0));
            addNewTile(board);
            addNewTile(board);
            return board;
        }

        // Добавление новой плитки на игровое поле
        function addNewTile(board) {
            let emptyCells = [];
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === 0) {
                        emptyCells.push({ x: i, y: j });
                    }
                }
            }
            if (emptyCells.length > 0) {
                let { x, y } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                board[x][y] = Math.random() < 0.9 ? 2 : 4;
            }
        }

        // Увеличение счета
        function increaseScore(value) {
            score += value;
            document.getElementById('score').textContent = 'Score: ' + score;
        }

        // Проверка наличия доступных ходов
        function checkMovesAvailable(board) {
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === 0) {
                        return true; // Есть пустая ячейка
                    }
                    if ((i < BOARD_SIZE - 1 && board[i][j] === board[i + 1][j]) || // Есть возможные слияния по вертикали
                        (j < BOARD_SIZE - 1 && board[i][j] === board[i][j + 1])) { // Есть возможные слияния по горизонтали
                        return true;
                    }
                }
            }
            return false; // Ходы больше не возможны
        }

        // Выполнение хода
        function move(board, direction) {
            let newBoard = JSON.parse(JSON.stringify(board)); // Создание копии игрового поля
            switch (direction) {
                case 'up':
                    return moveUp(newBoard);
                case 'down':
                    return moveDown(newBoard);
                case 'left':
                    return moveLeft(newBoard);
                case 'right':
                    return moveRight(newBoard);
                default:
                    return board;
            }
        }

        // Перемещение чисел вверх и слияние одинаковых чисел
        function moveUp(board) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                for (let i = 1; i < BOARD_SIZE; i++) {
                    if (board[i][j] !== 0) {
                        let k = i;
                        while (k > 0 && (board[k - 1][j] === 0 || board[k - 1][j] === board[k][j])) {
                            if (board[k - 1][j] === board[k][j]) {
                                board[k - 1][j] *= 2;
                                increaseScore(board[k - 1][j]); // Увеличение счета при слиянии
                                board[k][j] = 0;
                                break;
                            }
                            if (board[k - 1][j] === 0) {
                                board[k - 1][j] = board[k][j];
                                board[k][j] = 0;
                            }
                            k--;
                        }
                    }
                }
            }
            return board;
        }

        // Перемещение чисел вниз и слияние одинаковых чисел
        function moveDown(board) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                for (let i = BOARD_SIZE - 2; i >= 0; i--) {
                    if (board[i][j] !== 0) {
                        let k = i;
                        while (k < BOARD_SIZE - 1 && (board[k + 1][j] === 0 || board[k + 1][j] === board[k][j])) {
                            if (board[k + 1][j] === board[k][j]) {
                                board[k + 1][j] *= 2;
                                increaseScore(board[k + 1][j]); // Увеличение счета при слиянии
                                board[k][j] = 0;
                                break;
                            }
                            if (board[k + 1][j] === 0) {
                                board[k + 1][j] = board[k][j];
                                board[k][j] = 0;
                            }
                            k++;
                        }
                    }
                }
            }
            return board;
        }

        // Перемещение чисел влево и слияние одинаковых чисел
        function moveLeft(board) {
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 1; j < BOARD_SIZE; j++) {
                    if (board[i][j] !== 0) {
                        let k = j;
                        while (k > 0 && (board[i][k - 1] === 0 || board[i][k - 1] === board[i][k])) {
                            if (board[i][k - 1] === board[i][k]) {
                                board[i][k - 1] *= 2;
                                increaseScore(board[i][k - 1]); // Увеличение счета при слиянии
                                board[i][k] = 0;
                                break;
                            }
                            if (board[i][k - 1] === 0) {
                                board[i][k - 1] = board[i][k];
                                board[i][k] = 0;
                            }
                            k--;
                        }
                    }
                }
            }
            return board;
        }

        // Перемещение чисел вправо и слияние одинаковых чисел
        function moveRight(board) {
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = BOARD_SIZE - 2; j >= 0; j--) {
                    if (board[i][j] !== 0) {
                        let k = j;
                        while (k < BOARD_SIZE - 1 && (board[i][k + 1] === 0 || board[i][k + 1] === board[i][k])) {
                            if (board[i][k + 1] === board[i][k]) {
                                board[i][k + 1] *= 2;
                                increaseScore(board[i][k + 1]); // Увеличение счета при слиянии
                                board[i][k] = 0;
                                break;
                            }
                            if (board[i][k + 1] === 0) {
                                board[i][k + 1] = board[i][k];
                                board[i][k] = 0;
                            }
                            k++;
                        }
                    }
                }
            }
            return board;
        }

        // Функция для отрисовки игрового поля
        function render(board) {
            let gameContainer = document.getElementById('game-container');
            gameContainer.innerHTML = ''; // Очищаем содержимое элемента

            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.textContent = board[i][j] === 0 ? '' : board[i][j];
                    cell.style.backgroundColor = getTileColor(board[i][j]);
                    gameContainer.appendChild(cell);
                }
            }

            // Проверка доступности ходов и отображение кнопки новой игры при необходимости
            if (!checkMovesAvailable(board)) {
                document.getElementById('game-overlay').classList.add('active'); // Добавляем класс для показа затемнения
            } else {
                document.getElementById('game-overlay').classList.remove('active'); // Удаляем класс, если ходы доступны
            }
        }

        // Функция для определения цвета плитки в зависимости от значения
        function getTileColor(value) {
            switch (value) {
                case 2:
                    return '#A3AAFF';
                case 4:
                    return '#B696F4';
                case 8:
                    return '#CA81E8';
                case 16:
                    return '#DD6DDD';
                case 32:
                    return '#E67D9A';
                case 64:
                    return '#EA8579';
                case 128:
                    return '#D26A7D';
                case 256:
                    return '#BA4E80';
                case 512:
                    return '#A23384';
                case 1024:
                    return '#862E9C';
                case 2048:
                    return '#6B2AB5';
                default:
                    return '#0E0361';
            }
        }

        // Обработка нажатия клавиш на клавиатуре
        document.addEventListener('keydown', function (event) {
            let direction;
            switch (event.key) {
                case 'ArrowUp':
                    direction = 'up';
                    break;
                case 'ArrowDown':
                    direction = 'down';
                    break;
                case 'ArrowLeft':
                    direction = 'left';
                    break;
                case 'ArrowRight':
                    direction = 'right';
                    break;
                default:
                    return;
            }
            // Выполнение хода и обновление игрового поля
            board = move(board, direction);
            addNewTile(board);
            render(board);
        });

        // Обработка касаний на сенсорном экране
        let startX, startY;

        document.getElementById('game-container').addEventListener('touchstart', function (event) {
            startX = event.touches[0].clientX;
            startY = event.touches[0].clientY;
        });

        document.getElementById('game-container').addEventListener('touchmove', function (event) {
            event.preventDefault();
        });

        document.getElementById('game-container').addEventListener('touchend', function (event) {
            let endX = event.changedTouches[0].clientX;
            let endY = event.changedTouches[0].clientY;

            let deltaX = endX - startX;
            let deltaY = endY - startY;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0) {
                    // Swipe right
                    board = move(board, 'right');
                } else {
                    // Swipe left
                    board = move(board, 'left');
                }
            } else {
                if (deltaY > 0) {
                    // Swipe down
                    board = move(board, 'down');
                } else {
                    // Swipe up
                    board = move(board, 'up');
                }
            }

            addNewTile(board);
            render(board);
        });

        // Инициализация игры
        let board = newGame();
        render(board);

        // Обработка клика на кнопке новой игры
        document.getElementById('new-game-button').addEventListener('click', function () {
            score = 0;
            document.getElementById('score').textContent = 'Score: ' + score;
            board = newGame();
            render(board);
        });
    </script>
</body>
</html>
