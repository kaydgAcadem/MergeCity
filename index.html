<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merge City</title>
    <link rel="stylesheet" type="text/css" href="styles.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>

    <script>
        function startNewGame() {
            let board = newGame();
            render(board);
            return board;
        }
    </script>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            let usercard = document.getElementById("usercard");
            let profName = document.createElement('p');

            if (tg.initDataUnsafe && tg.initDataUnsafe.user) {
                profName.innerText = `${tg.initDataUnsafe.user.first_name} (${tg.initDataUnsafe.user.language_code})`;
            } else {
                profName.innerText = 'No Name';
            }

            usercard.appendChild(profName);
        });
    </script>
</head>
<body>
<div class="top-container">
    <div id="usercard"></div>
    <div id="ton-connect"></div>
</div>
<div id="score">Score: 0</div>
<div id="game-container"></div>
<div id="game-overlay">
    <button id="new-game-button">&#8634;</button>
</div>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        const tonConnectUI = new TON_CONNECT_UI.TonConnectUI({
            manifestUrl: 'https://kaydgacadem.github.io/MergeCity/tonconnect-manifest.json',
            buttonRootId: 'ton-connect'
        });

        async function connectToWallet() {
            try {
                const connectedWallet = await tonConnectUI.connectWallet();
                if (connectedWallet && connectedWallet.account && connectedWallet.account.address) {
                    const address = connectedWallet.account.address;
                    console.log("Адрес вашего кошелька:", address);
                    return connectedWallet;
                } else {
                    console.error('Ошибка: Неверный формат объекта connectedWallet или отсутствует адрес');
                }
            } catch (error) {
                console.error('Ошибка подключения к кошельку:', error);
            }
        }

        connectToWallet().then(connectedWallet => {
            window.connectedWallet = connectedWallet;
        });
    });
</script>

<script>
    let tg = window.Telegram.WebApp;
    tg.expand(ignore_collapsing=true);
    tg.onEvent('viewportChanged', () => {
        if (!tg.isExpanded) {
            tg.expand();
        }
    })
    tg.enableClosingConfirmation();

    const BOARD_SIZE = 4;
    let score = 0;

    function newGame() {
        let board = new Array(BOARD_SIZE).fill(0).map(() => new Array(BOARD_SIZE).fill(0));
        addNewTile(board);
        addNewTile(board);
        return board;
    }

    function addNewTile(board) {
        let emptyCells = [];
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                if (board[i][j] === 0) {
                    emptyCells.push({x: i, y: j});
                }
            }
        }
        if (emptyCells.length > 0) {
            let {x, y} = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            board[x][y] = Math.random() < 0.9 ? 2 : 4;
        }
    }

    function increaseScore(value) {
        score += value;
        document.getElementById('score').textContent = 'Score: ' + score;
    }

    function checkMovesAvailable(board) {
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                if (board[i][j] === 0) {
                    return true;
                }
                if ((i < BOARD_SIZE - 1 && board[i][j] === board[i + 1][j]) ||
                    (j < BOARD_SIZE - 1 && board[i][j] === board[i][j + 1])) {
                    return true;
                }
            }
        }
        return false;
    }

    function move(board, direction) {
        let newBoard = JSON.parse(JSON.stringify(board));
        switch (direction) {
            case 'up':
                return moveUp(newBoard);
            case 'down':
                return moveDown(newBoard);
            case 'left':
                return moveLeft(newBoard);
            case 'right':
                return moveRight(newBoard);
            default:
                return board;
        }
    }

    function moveUp(board) {
        for (let j = 0; j < BOARD_SIZE; j++) {
            for (let i = 1; i < BOARD_SIZE; i++) {
                if (board[i][j] !== 0) {
                    let k = i;
                    while (k > 0 && (board[k - 1][j] === 0 || board[k - 1][j] === board[k][j])) {
                        if (board[k - 1][j] === board[k][j]) {
                            board[k - 1][j] *= 2;
                            increaseScore(board[k - 1][j]);
                            if (board[k - 1][j] === 64) {
                                createNewWinnerEntry(window.connectedWallet.account.address, score);
                            }
                            board[k][j] = 0;
                            break;
                        }
                        if (board[k - 1][j] === 0) {
                            board[k - 1][j] = board[k][j];
                            board[k][j] = 0;
                        }
                        k--;
                    }
                }
            }
        }
        return board;
    }

    function moveDown(board) {
        for (let j = 0; j < BOARD_SIZE; j++) {
            for (let i = BOARD_SIZE - 2; i >= 0; i--) {
                if (board[i][j] !== 0) {
                    let k = i;
                    while (k < BOARD_SIZE - 1 && (board[k + 1][j] === 0 || board[k + 1][j] === board[k][j])) {
                        if (board[k + 1][j] === board[k][j]) {
                            board[k + 1][j] *= 2;
                            increaseScore(board[k + 1][j]);
                            if (board[k + 1][j] === 64) {
                                createNewWinnerEntry(window.connectedWallet.account.address, score);
                            }
                            board[k][j] = 0;
                            break;
                        }
                        if (board[k + 1][j] === 0) {
                            board[k + 1][j] = board[k][j];
                            board[k][j] = 0;
                        }
                        k++;
                    }
                }
            }
        }
        return board;
    }

    function moveLeft(board) {
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 1; j < BOARD_SIZE; j++) {
                if (board[i][j] !== 0) {
                    let k = j;
                    while (k > 0 && (board[i][k - 1] === 0 || board[i][k - 1] === board[i][k])) {
                        if (board[i][k - 1] === board[i][k]) {
                            board[i][k - 1] *= 2;
                            increaseScore(board[i][k - 1]);
                            if (board[i][k - 1] === 64) {
                                createNewWinnerEntry(window.connectedWallet.account.address, score);
                            }
                            board[i][k] = 0;
                            break;
                        }
                        if (board[i][k - 1] === 0) {
                            board[i][k - 1] = board[i][k];
                            board[i][k] = 0;
                        }
                        k--;
                    }
                }
            }
        }
        return board;
    }

    function moveRight(board) {
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = BOARD_SIZE - 2; j >= 0; j--) {
                if (board[i][j] !== 0) {
                    let k = j;
                    while (k < BOARD_SIZE - 1 && (board[i][k + 1] === 0 || board[i][k + 1] === board[i][k])) {
                        if (board[i][k + 1] === board[i][k]) {
                            board[i][k + 1] *= 2;
                            increaseScore(board[i][k + 1]);
                            if (board[i][k + 1] === 64) {
                                createNewWinnerEntry(window.connectedWallet.account.address, score);
                            }
                            board[i][k] = 0;
                            break;
                        }
                        if (board[i][k + 1] === 0) {
                            board[i][k + 1] = board[i][k];
                            board[i][k] = 0;
                        }
                        k++;
                    }
                }
            }
        }
        return board;
    }

    function render(board) {
        let gameContainer = document.getElementById('game-container');
        gameContainer.innerHTML = '';

        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                let cell = document.createElement('div');
                cell.className = 'cell';
                cell.textContent = board[i][j] === 0 ? '' : board[i][j];
                cell.style.backgroundColor = getTileColor(board[i][j]);
                gameContainer.appendChild(cell);
            }
        }

        if (!checkMovesAvailable(board)) {
            document.getElementById('game-overlay').classList.add('active');
        } else {
            document.getElementById('game-overlay').classList.remove('active');
        }
    }

    function getTileColor(value) {
        switch (value) {
            case 2:
                return '#A3AAFF';
            case 4:
                return '#B696F4';
            case 8:
                return '#CA81E8';
            case 16:
                return '#DD6DDD';
            case 32:
                return '#E67D9A';
            case 64:
                return '#EA8579';
            case 128:
                return '#D26A7D';
            case 256:
                return '#BA4E80';
            case 512:
                return '#A23384';
            case 1024:
                return '#862E9C';
            case 2048:
                return '#6B2AB5';
            default:
                return 'tile-default';
        }
    }

    function createNewWinnerEntry(address, score) {
    const data = {
        connectedWallet: {
            account: {
                address: address
            }
        },
        score: score
    };

    console.log(JSON.stringify(data)); // Проверяем формат данных перед отправкой

    fetch('https://mcity.kaydg.keenetic.pro/saveWinner', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(data => {
        console.log('Server response:', data);
    })
    .catch(error => {
        console.error('Error sending data to server:', error);
    });
}


    document.addEventListener('keydown', function (event) {
        let direction;
        switch (event.key) {
            case 'ArrowUp':
                direction = 'up';
                break;
            case 'ArrowDown':
                direction = 'down';
                break;
            case 'ArrowLeft':
                direction = 'left';
                break;
            case 'ArrowRight':
                direction = 'right';
                break;
            default:
                return;
        }
        board = move(board, direction);
        addNewTile(board);
        render(board);
    });

    let startX, startY;

    document.getElementById('game-container').addEventListener('touchstart', function (event) {
        startX = event.touches[0].clientX;
        startY = event.touches[0].clientY;
    });

    document.getElementById('game-container').addEventListener('touchmove', function (event) {
        event.preventDefault();
    });

    document.getElementById('game-container').addEventListener('touchend', function (event) {
        let endX = event.changedTouches[0].clientX;
        let endY = event.changedTouches[0].clientY;

        let deltaX = endX - startX;
        let deltaY = endY - startY;

        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            if (deltaX > 0) {
                board = move(board, 'right');
            } else {
                board = move(board, 'left');
            }
        } else {
            if (deltaY > 0) {
                board = move(board, 'down');
            } else {
                board = move(board, 'up');
            }
        }

        addNewTile(board);
        render(board);
    });

    let board = newGame();
    render(board);

    document.getElementById('new-game-button').addEventListener('click', function () {
        score = 0;
        document.getElementById('score').textContent = 'Score: ' + score;
        board = newGame();
        render(board);
    });
</script>

</body>
</html>
